%
% Complete documentation on the extended LaTeX markup used for Insight
% documentation is available in ``Documenting Insight'', which is part
% of the standard documentation for Insight.  It may be found online
% at:
%
%     http://www.itk.org/

\documentclass{InsightArticle}

\usepackage[dvips]{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}

\def\x{{\mathbf x}}
\def\m{{\mathbf m}}
\def\v{{\overrightarrow{\mathbf v}}}

%  This is a template for Papers to the Insight Journal. 
%  It is comparable to a technical report format.

% The title should be descriptive enough for people to be able to find
% the relevant document. 
\title{Boolean Operations for Surfaces in VTK Without External Libraries}

% 
% NOTE: This is the last number of the "handle" URL that 
% The Insight Journal assigns to your paper as part of the
% submission process. Please replace the number "1338" with
% the actual handle number that you get assigned.
%
\newcommand{\IJhandlerIDnumber}{1338}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
\release{1.00}

% At minimum, give your name and an email address.  You can include a
% snail-mail address if you like.
\author{Cory Quammen, Chris Weigle, and Russell M. Taylor II}
\authoraddress{Department of Computer Science\\
             The University of North Carolina at Chapel Hill
}

\begin{document}

%
% Add hyperlink to the web location and license of the paper.
% The argument of this command is the handler identifier given
% by the Insight Journal to this paper.
% 
\IJhandlefooter{\IJhandlerIDnumber}


\ifpdf
\else
   %
   % Commands for including Graphics when using latex
   % 
   \DeclareGraphicsExtensions{.eps,.jpg,.gif,.tiff,.bmp,.png}
   \DeclareGraphicsRule{.jpg}{eps}{.jpg.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.gif}{eps}{.gif.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.tiff}{eps}{.tiff.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.bmp}{eps}{.bmp.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.png}{eps}{.png.bb}{`convert #1 eps:-}
\fi


\maketitle


\ifhtml
\chapter*{Front Matter\label{front}}
\fi


% The abstract should be a paragraph or two long, and describe the
% scope of the document.
\begin{abstract}
\noindent
We have written a set of classes than enable boolean operations on surface meshes defined in \code{vtkPolyData} objects using only VTK classes. Our contribution offers some feature enhancements over previous solutions, namely, preservation of mesh topology and passing point data and cell data through to outputs.

\end{abstract}

\IJhandlenote{\IJhandlerIDnumber}

\tableofcontents

\section{Introduction}

Let $A$ and $B$ be sets. A \emph{boolean operation} can be used to define a third set $C$. Three common boolean operations on sets are:

\begin{description}

\item Union

 $C = A \cup B = \{ x \, | \, x \in A \text{ or } x \in B \}$

\item Intersection

$C = A \cap B = \{ x \, | \, x \in A \text{ and } x \in B \}$

\item Difference

$C = A - B = \{ x \, | \, x \in A \text{ and } x \notin B \}$

\end{description}

In geometric modeling, a surface mesh $M_A$ may be considered the boundary of a space-filling set of 3D points $A$ if $M_A$ is a closed, orientable 2-manifold surface in 3D. Given a second surface mesh $M_B$ with the same properties, a boolean operation may be applied to obtain a third surface mesh $M_C$. These simple operations can be used to define complex geometries.

Rather than convert two mesh representations to a set of points, perform the boolean operations on those points, and reconstruct a third mesh from the resulting points, direct operations on the bounding geometry based on signed distance fields and mesh-to-mesh clipping can be used. This article describes an implementation of those methods to realize boolean operations on surfaces in VTK.

\section{Mesh-to-Mesh Signed Distance Calculation}

The distance field $f(\x)$ of a mesh is defined as the distance from $\x$ to the nearest point on the mesh. The signed distance field is similar to the distance field, but the sign of the field is negative for locations $\x$ inside the mesh and positive for locations $\x$ outside the mesh. To determine whether $\x$ is inside or outside the mesh, a vector $\v = \x - \m$ is defined where $\m$ is the nearest point on the mesh. The sign of the distance field is the same as the dot product of $\v$ with the \emph{angle-weighted pseudo-normal} of the mesh at $\m$ when the mesh is a closed, orientable 2-manifold surfaces in 3D Euclidean space \cite{Baerentzen2005}.  

The angle-weighted pseudo-normal is defined separately for faces, edges, and points in a mesh. For faces, it is simply the normal of the triangle. For an edge, it is the average of the normals for the faces that share the edge. For a point, it is the sum of the angle-weighted normals from each face where the weight for a face normal is the angle between the two edges of that face incident to the point.

We introduce the \code{vtkImplicitPolyData} class that defines a signed distance function given an input \code{vtkPolyData}. This class is a subclass of \code{vtkImplicitFunction}, so it can be used by classes that operate on \code{vtkImplicitFunction} objects (see, e.g., \code{vtkSampleFunction}). The method XXXX is overridden to return the signed distance, and XXXX is overridden to return the angle-weighted pseudo-normal.

To support boolean operations, we introduce another class, \code{vtkPolyDataDistance}, that computes the distance from the first input \code{vtkPolyData} to a second. Optionally, the distance field from the second input \code{vtkPolyData} to the first can also be computed. These distances are computed at points in the mesh and are stored as a point data field named ``Distance''.

\section{Boolean Operations Using Signed Distance}

Boolean operations can be computed with only the signed distance field for each mesh. As the sign of the distance field at a point in the mesh corresponds to whether that point is inside (negative) or outside (positive) the other mesh, the surfaces bounding the volumes produced by the boolean operations are:

\begin{description}

\item Union

The union of two meshes is the set of cells in each mesh such that the distance from each cell point to the other mesh is greater than or equal to zero.

\item Intersection

The intersection of two meshes is the set of cells in each mesh such that the distance from each cell point to the other mesh is less than or equal to zero.

\item Difference

Given meshes $A$ and $B$, the difference $A-B$ is defined by the cells of $A$ with positive distance from $B$ and the cells of $B$ with negative distance from $A$.

\end{description}

\section{Clipping One Surface with Another Surface}

While it seems possible to use the class \code{vtkClipPolyData} together with \code{vtkImplicitPolyData} to extract the necessary portions of each input surface to produce the union, intersection, and difference surfaces, there is a problem. \code{vtkClipPolyData} assumes that the implicit function is piecewise linear within each cell of the \code{vtkPolyData} being clipped. However, in general, implicit functions are not guaranteed to be piecewise linear in each cell, and the same is true for the signed distance field. The result is that clipped surfaces produced by \code{vtkClipPolyData} will not be clipped at the zero-level of the distance field. Consequently, the clipped portions of each input geometry will not match at the zero-level where they should fuse seemlessly [INSERT FIGURE].

Instead of directly clipping the input meshes based on the signed distance evaluated at mesh points, it is necessary to split each input mesh at the actual intersection of the two surfaces (hereafter referred to as the \emph{surface intersection}). This step is the most complex part of computing boolean operations on surface meshes.

\subsection{Identifying the Surface Intersection}

Identifying the surface intersection of a mesh with another mesh involves identifying the intersection between each triangle in the first mesh with the triangles that intersect it in the second mesh. A triangle-triangle intersection test yields two end points of the line segment defining the intersection for non-coplanar triangles; this contribution does not explicitly handle intersections between two coplanar triangles. 

Oriented bounding box (OBB) trees are used to accelerate the identification of triangle-triangle intersections between meshes. Two \code{vtkOBBTree} objects are instantiated, one for each input mesh. The method \code{vtkOBBTree::IntersectWithOBBTree()} is then called on one OBB tree with the second OBB tree and a callback function passed as parameters. The callback function performs exact triangle-triangle intersection tests between the triangles in overlapping nodes from the two OBB trees and stores the results in several data structures used later in the algorithm.

End points from the triangle-triangle intersections are stored in a \code{vtkPoints} object and the line cells are stored in a \code{vtkCellArray}. The points  are merged using a \code{vtkPointLocator} object with a small tolerance, leading to many fewer connected components than if the line segments were stored as ``line soup''. In addition, each end point is tested to see if it lies on each edge of the two input triangles. If so, the index of the triangle, the index of the edge, and the index of the intersecting line is associated with the index of the endpoint in a \code{std::multimap} for later use.

The end point-edge intersection information is used to split the fully connected intersection lines to respect the topology of each input mesh. Because the end points of the intersection lines are merged during construction, they need to be split where the mesh is split. The end result should be that a copy of each line end point is produced for each set of triangles that share an edge. This can be achieved by iterating over the elements in the end point-edge intersection \code{std::multimap}, creating a copy of the point, and removing all records in the multimap where the cell ID is the same as one identified as sharing the the edge in question.

\subsection{Splitting the Mesh}

After the intersection lines are split for a mesh, the next step is to identify candidate cells for splitting. A cell is a candidate cell in two cases:

\begin{enumerate}
\item The cell index is in the intersection line map, meaning that intersection lines lie inside the cell.
\item The cell is the neighbor of a cell identified by case 1.
\end{enumerate}

The second case is important because one of the mesh-mesh intersection lines may have an endpoint on the edge of one cell, but no line that uses that endpoint on the cell neighbor across that edge. The cell neighbor needs to be split to avoid introducing a T-junction and therefore a hole in the output mesh.

Splitting proceeds on a cell-by-cell basis. For each cell that needs splitting, the following data is gathered:

\begin{enumerate}
\item The three points that define the cell.
\item The boundary lines of the cell.
\item The split intersection lines that lie in the cell (if any).
\item The points that define the lines in 3.
\item Points from neighboring cells that lie on a cell edge but which were not already added in 4.
\end{enumerate}

The lines collected above are used to constrain the new triangulation of the points. That is to say, these lines should be present in the output mesh. Special processing of the boundary lines is required to achieve the desired split. Specifically, boundary lines must be split at points that lie on them. Boundary line splitting is achieved by sorting points on the boundary lines according to the angle between the first edge of the cell and the vector formed by subtracting the cell center from the point and connecting points adjacent to each other with lines. Because the last boundary point is connected to the first, the absolute order of the boundary points is not important.

The \code{vtkDelaunay2D} class can be used to determine a triangulation from the cell, surface intersection lines, and boundary points and lines. A transformation of the points collected above that rotates them to the XY-plane is calculated is computed and set as the transform for the \code{vtkDelaunay2D} object. A new \code{vtkPolyData} object that contains the collected points and lines is defined and passed as both the input and constraint source to a \code{vtkDelaunay2D} object. The line point indices are renumbered to point to their locations in the new \code{vtkPolyData} object, and a map back to their original indices is created to remap the output cell indices from the triangulation to the point indices in the output mesh. If a point in the surface intersection is within some small tolerance distance from a point in the surface mesh, the point in the surface mesh is used instead.

\section{Limitations}

These classes do not properly handle intersections between coplanar triangles. When such an intersection event has been detected, the intersection information is discarded. Such intersections likely occur when portions of the meshes are immediately adjacent to each other, however, and their exclusion from the surface-to-surface intersection information will usually not affect the mesh splitting results.

\section{Software Requirements}

The source code contributed with this article has been build against VTK 5.8.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Example on how to insert a figure
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\center
%\includegraphics[width=0.8\textwidth]{RegistrationComponentsDiagram.eps}
\itkcaption[Registration Framework Components]{The basic components of the
registration framework are two input images, a transform, a metric, an
interpolator and an optimizer.}
\label{fig:RegistrationComponents}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Insert the bibliography using BibTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{Article}


\end{document}

